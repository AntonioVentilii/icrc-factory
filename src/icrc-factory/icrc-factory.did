type Account = record { owner : principal; subaccount : opt blob };
type Args = variant { Upgrade; Init : InitArgs };
type CallerPaysIcrc2Tokens = record { ledger : principal };
type Config = record { cycles_ledger : principal };
type CreateCanisterError = variant {
	CanisterCreationFailed : text;
	NoWasmStored;
	WasmInstallationFailed : text;
	PaymentError : PaymentError;
	InitArgsEncodingFailed : text
};
type CreateCanisterResult = variant {
	Ok : principal;
	Err : CreateCanisterError
};
type CreateIcrcIndexArgs = record { ledger_id : principal };
type CreateIcrcLedgerArgs = record {
	decimals : opt nat8;
	transfer_fee : opt nat64;
	minting_account : opt Account;
	name : opt text;
	symbol : opt text
};
type HttpHeader = record { value : text; name : text };
type HttpResponse = record {
	status : nat;
	body : blob;
	headers : vec HttpHeader
};
type InitArgs = record { cycles_ledger : opt principal };
type PatronPaysIcrc2Tokens = record { ledger : principal; patron : Account };
type PaymentError = variant {
	LedgerWithdrawFromError : record {
		error : WithdrawFromError;
		ledger : principal
	};
	LedgerUnreachable : CallerPaysIcrc2Tokens;
	InvalidPatron;
	LedgerTransferFromError : record {
		error : TransferFromError;
		ledger : principal
	};
	UnsupportedPaymentType;
	InsufficientFunds : record { needed : nat64; available : nat64 }
};
type PaymentType = variant {
	PatronPaysIcrc2Tokens : PatronPaysIcrc2Tokens;
	AttachedCycles;
	CallerPaysIcrc2Cycles;
	CallerPaysIcrc2Tokens : CallerPaysIcrc2Tokens;
	PatronPaysIcrc2Cycles : Account
};
type RejectionCode = variant {
	NoError;
	CanisterError;
	SysTransient;
	DestinationInvalid;
	Unknown;
	SysFatal;
	CanisterReject
};
type SetCanisterResult = variant { Ok : record {}; Err : CreateCanisterError };
type SetIndexCanisterArgs = record {
	ledger_id : principal;
	index_id : principal
};
type SetNameArgs = record { name : text; ledger_id : principal };
type SetSymbolArgs = record { ledger_id : principal; symbol : text };
type SetWasmResult = variant { Ok : nat64; Err : text };
type TransferFromError = variant {
	GenericError : record { message : text; error_code : nat };
	TemporarilyUnavailable;
	InsufficientAllowance : record { allowance : nat };
	BadBurn : record { min_burn_amount : nat };
	Duplicate : record { duplicate_of : nat };
	BadFee : record { expected_fee : nat };
	CreatedInFuture : record { ledger_time : nat64 };
	TooOld;
	InsufficientFunds : record { balance : nat }
};
type TransformArgs = record { context : blob; response : HttpResponse };
type UserCanister = record {
	kind : UserCanisterKind;
	installed : bool;
	canister_id : principal
};
type UserCanisterKind = variant { IcrcIndex; IcrcLedger };
type WithdrawFromError = variant {
	GenericError : record { message : text; error_code : nat };
	TemporarilyUnavailable;
	InsufficientAllowance : record { allowance : nat };
	Duplicate : record { duplicate_of : nat };
	InvalidReceiver : record { receiver : principal };
	CreatedInFuture : record { ledger_time : nat64 };
	TooOld;
	FailedToWithdrawFrom : record {
		withdraw_from_block : opt nat;
		rejection_code : RejectionCode;
		refund_block : opt nat;
		approval_refund_block : opt nat;
		rejection_reason : text
	};
	InsufficientFunds : record { balance : nat }
};
service : (Args) -> {
	// Returns the current canister configuration.
	//
	// # Access Control
	// - Caller must not be anonymous.
	//
	// # Returns
	// - A clone of the stored `Config`.
	config : () -> (Config) query;
	// Creates a new ICRC index canister for an existing ledger.
	//
	// # Access Control
	// - Caller must not be anonymous.
	//
	// # Arguments
	// - `args`: [`CreateIcrcIndexArgs`]
	// - `ledger_id`: **required** principal of the ledger to index.
	// - `payment`: Optional [`PaymentType`]
	// - If `None`, defaults to `PaymentType::AttachedCycles`.
	//
	// # Returns
	// - `CreateCanisterResult::Ok(Principal)` containing the newly created index canister ID.
	// - `CreateCanisterResult::Err(CreateCanisterError)` if payment deduction fails or if canister
	// creation / init-args encoding / WASM installation fails.
	create_icrc_index : (CreateIcrcIndexArgs, opt PaymentType) -> (
		CreateCanisterResult
	);
	// Creates a new ICRC ledger canister.
	//
	// # Access Control
	// - Caller must not be anonymous.
	//
	// # Arguments
	// - `args`: [`CreateIcrcLedgerArgs`]
	// - All fields inside `args` are optional:
	// - `symbol`: optional token symbol
	// - `name`: optional token name
	// - `transfer_fee`: optional fee (smallest unit)
	// - `decimals`: optional decimals
	// - `minting_account`: optional minting account
	// - Any omitted fields fall back to the ledger’s defaults.
	// - `payment`: Optional [`PaymentType`]
	// - If `None`, defaults to `PaymentType::AttachedCycles`.
	//
	// # Returns
	// - `CreateCanisterResult::Ok(Principal)` containing the newly created ledger canister ID.
	// - `CreateCanisterResult::Err(CreateCanisterError)` if payment deduction fails or if canister
	// creation / init-args encoding / WASM installation fails.
	create_icrc_ledger : (CreateIcrcLedgerArgs, opt PaymentType) -> (
		CreateCanisterResult
	);
	list_all_canisters_paginated : (opt nat64, opt nat64) -> (
		vec UserCanister
	) query;
	list_user_canisters : () -> (vec UserCanister) query;
	// Associates an index canister with a ledger by upgrading the ledger configuration.
	//
	// # Access Control
	// - Caller must not be anonymous.
	//
	// # Arguments
	// - `args`: [`SetIndexCanisterArgs`]
	// - `ledger_id`: **required** principal of the ledger to update.
	// - `index_id`: **required** principal of the index canister to associate.
	//
	// # Returns
	// - `SetCanisterResult::Ok(())` on success.
	// - `SetCanisterResult::Err(CreateCanisterError)` if the ledger upgrade fails.
	set_index_canister : (SetIndexCanisterArgs) -> (SetCanisterResult);
	// Stores a new ICRC index WASM binary.
	//
	// # Access Control
	// - Caller must be a controller.
	//
	// # Arguments
	// - `wasm`: Raw WASM bytecode to store.
	set_index_wasm : (blob) -> ();
	// Fetches and stores an ICRC index WASM binary from a URL.
	//
	// # Access Control
	// - Caller must be a controller.
	//
	// # Arguments
	// - `url`: URL pointing to the WASM binary.
	//
	// # Returns
	// - `SetWasmResult` indicating success or failure.
	set_index_wasm_from_url : (text) -> (SetWasmResult);
	// Stores a new ICRC ledger WASM binary.
	//
	// # Access Control
	// - Caller must be a controller.
	//
	// # Arguments
	// - `wasm`: Raw WASM bytecode to store.
	set_ledger_wasm : (blob) -> ();
	// Fetches and stores an ICRC ledger WASM binary from a URL.
	//
	// # Access Control
	// - Caller must be a controller.
	//
	// # Arguments
	// - `url`: URL pointing to the WASM binary.
	//
	// # Returns
	// - `SetWasmResult` indicating success or failure.
	set_ledger_wasm_from_url : (text) -> (SetWasmResult);
	// Updates a ledger’s token name by upgrading the ledger configuration.
	//
	// # Access Control
	// - Caller must not be anonymous.
	//
	// # Arguments
	// - `args`: [`SetNameArgs`]
	// - `ledger_id`: **required** principal of the ledger to update.
	// - `name`: **required** new token name.
	//
	// # Returns
	// - `SetCanisterResult::Ok(())` on success.
	// - `SetCanisterResult::Err(CreateCanisterError)` if the ledger upgrade fails.
	set_name : (SetNameArgs) -> (SetCanisterResult);
	// Updates a ledger’s token symbol by upgrading the ledger configuration.
	//
	// # Access Control
	// - Caller must not be anonymous.
	//
	// # Arguments
	// - `args`: [`SetSymbolArgs`]
	// - `ledger_id`: **required** principal of the ledger to update.
	// - `symbol`: **required** new token symbol.
	//
	// # Returns
	// - `SetCanisterResult::Ok(())` on success.
	// - `SetCanisterResult::Err(CreateCanisterError)` if the ledger upgrade fails.
	set_symbol : (SetSymbolArgs) -> (SetCanisterResult);
	// Transforms HTTP responses when fetching WASM binaries.
	//
	// # Purpose
	// - Used as an HTTP transform function to sanitise responses from external WASM sources.
	//
	// # Arguments
	// - `args`: HTTP transform arguments provided by the IC.
	//
	// # Returns
	// - A transformed `HttpResponse`.
	transform_wasm_response : (TransformArgs) -> (HttpResponse) query
}
